%%%----------------------------------------------------------------------
%%% ejabberd, Copyright (C) 2002-2019   ProcessOne
%%%
%%% This program is free software; you can redistribute it and/or
%%% modify it under the terms of the GNU General Public License as
%%% published by the Free Software Foundation; either version 2 of the
%%% License, or (at your option) any later version.
%%%
%%% This program is distributed in the hope that it will be useful,
%%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%%% General Public License for more details.
%%%
%%% You should have received a copy of the GNU General Public License along
%%% with this program; if not, write to the Free Software Foundation, Inc.,
%%% 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
%%%
%%%----------------------------------------------------------------------
-module(ejabberd_options_doc).

%% API
-export([doc/0]).

-include("translate.hrl").

%%%===================================================================
%%% API
%%%===================================================================
doc() ->
    [{hosts,
      #{value => ?T("[Domain1, Domain2, ...]"),
        desc =>
            ?T("The option defines a list containing one or more "
               "domains that 'ejabberd' will serve. This is a "
               "**mandatory** option.")}},
     {loglevel,
      #{value =>
            "none | emergency | alert | critical | "
            "error | warning | notice | info | debug",
        desc =>
            ?T("Verbosity of log files generated by ejabberd. "
               "The default value is 'info'. "
               "NOTE: previous versions of ejabberd had log levels "
               "defined in numeric format ('0..5'). The numeric values "
               "are still accepted for backward compatibility, but "
               "are not recommended.")}},
     {cache_life_time,
      #{value => "timeout()",
        desc =>
            ?T("The time of a cached item to keep in cache. "
               "Once it's expired, the corresponding item is "
               "erased from cache. The default value is 'one hour'.")}},
     {cache_missed,
      #{value => "true|false",
        desc =>
            ?T("Whether or not to cache missed lookups. When there is "
               "an attempt to lookup for a value in a database and "
               "this value is not found and the option is set to 'true', "
               "this attempt will be cached and no attempts will be "
               "performed until the cache expires (see 'cache_life_time'). "
               "Usually you don't want to change it. Default is 'true'.")}},
     {cache_size,
      #{value => "pos_integer()|infinity",
        desc =>
            ?T("A maximum number of items (not memory!) in cache. "
               "The rule of thumb, for all tables except rosters, "
               "you should set it to the number of maximum online "
               "users you expect. For roster multiply this number "
               "by 20 or so. If the cache size reaches this threshold, "
               "it's fully cleared, i.e. all items are deleted, and "
               "the corresponding warning is logged. You should avoid "
               "frequent cache clearance, because this degrades "
               "performance. The default value is '1000'.")}},
     {use_cache,
      #{value => "true|false",
        desc => ?T("Enable or disable cache. The default is 'true'.")}},
     {default_db,
      #{value => "mnesia|sql",
        desc =>
            ?T("Default persistent storage for ejabberd. "
               "Modules and other components (e.g. authentication) "
               "may have its own value. The default value is 'mnesia'.")}},
     {default_ram_db,
      #{value => "mnesia|sql|redis",
        desc =>
            ?T("Default volatile (in-memory) storage for ejabberd. "
               "Modules and other components (e.g. session management) "
               "may have its own value. The default value is 'mnesia'.")}},
     {queue_type,
      #{value => "ram|file",
        desc =>
            ?T("Default type of queues in ejabberd. "
               "Modules may have its own value of the option. "
               "The value of 'ram' means that queues will be kept in memory. "
               "If value 'file' is set, you may also specify directory "
               "in 'queue_dir' option where file queues will be placed. "
               "The default value is 'ram'.")}},
     {version,
      #{value => "string()",
        desc =>
            ?T("The option can be used to set custom ejabberd version, "
               "that will be used by different parts of ejabberd, for "
               "example by 'mod_version' module. The default value is "
               "obtained at compile time from the underlying version "
               "control system.")}},
     {acl,
      #{value => "{ACLName: {ACLType: ACLValue}}",
        desc =>
            ?T("The option defines access control lists: named sets "
               "of rules which are used to match against different targets "
               "(such as a JID or an IP address). Every set of rules "
               "has name 'ACLName': it can be any string except 'all' or 'none' "
               "(those are predefined names for the rules that match all or nothing "
               "respectively). The name 'ACLName' can be referenced from other "
               "parts of the configuration file, for example in 'access_rules' "
               "option. The rules of 'ACLName' are represented by mapping "
               "'pass:[{ACLType: ACLValue}]'. These can be one of the following:")},
      [{user,
        #{value => ?T("Username"),
          desc =>
              ?T("If 'Username' is in the form of \"user@server\", "
                 "the rule matches a JID against this value. "
                 "Otherwise, if 'Username' is in the form of \"user\", "
                 "the rule matches any JID that has 'Username' in the node part "
                 "as long as the server part of this JID is any virtual "
                 "host served by ejabberd.")}},
       {server,
        #{value => ?T("Server"),
          desc =>
              ?T("The rule matches any JID from server 'Server'. "
                 "The value of 'Server' must be a valid "
                 "hostname or an IP address.")}},
       {resource,
        #{value => ?T("Resource"),
          desc =>
              ?T("The rule matches any JID with a resource 'Resource'.")}},
       {ip,
        #{value => ?T("Network"),
          desc =>
              ?T("The rule matches any IP address from the 'Network'.")}},
       {user_regexp,
        #{value => ?T("Regexp"),
          desc =>
              ?T("If 'Regexp' is in the form of \"regexp@server\", the rule "
                 "matches any JID with node part matching regular expression "
                 "\"regexp\" as long as the server part of this JID is equal "
                 "to \"server\". If 'Regexp' is in the form of \"regexp\", the rule "
                 "matches any JID with node part matching regular expression "
                 "\"regexp\" as long as the server part of this JID is any virtual "
                 "host served by ejabberd.")}},
       {server_regexp,
        #{value => ?T("Regexp"),
          desc =>
              ?T("The rule matches any JID from the server that "
                 "matches regular expression 'Regexp'.")}},
       {resource_regexp,
        #{value => ?T("Regexp"),
          desc =>
              ?T("The rule matches any JID with a resource that "
                 "matches regular expression 'Regexp'.")}},
       {node_regexp,
        #{value => ?T("user_regexp@server_regexp"),
          desc =>
              ?T("The rule matches any JID with node part matching regular "
                 "expression 'user_regexp' and server part matching regular "
                 "expression 'server_regexp'.")}},
       {user_glob,
        #{value => ?T("Pattern"),
          desc =>
              ?T("Same as 'user_regexp', but matching is performed on a "
                 "specified 'Pattern' according to the rules used by the "
                 "Unix shell.")}},
       {server_glob,
        #{value => ?T("Pattern"),
          desc =>
              ?T("Same as 'server_regexp', but matching is performed on a "
                 "specified 'Pattern' according to the rules used by the "
                 "Unix shell.")}},
       {resource_glob,
        #{value => ?T("Pattern"),
          desc =>
              ?T("Same as 'resource_regexp', but matching is performed on a "
                 "specified 'Pattern' according to the rules used by the "
                 "Unix shell.")}},
       {node_glob,
        #{value => ?T("Pattern"),
          desc =>
              ?T("Same as 'node_regexp', but matching is performed on a "
                 "specified 'Pattern' according to the rules used by the "
                 "Unix shell.")}}]},
     {access_rules,
      #{value => "{AccessName: {allow|deny: ACLRule|ACLName}}",
        desc =>
            ?T("The option specifies access rules. TODO")}},
     {acme,
      #{value => ?T("Options"),
        desc =>
            ?T("ACME configuration. ACME is used to automatically "
               "obtain SSL certificates for the domains served by ejabberd, "
               "which means that certificate requests and renewals are "
               "performed to some CA server (aka \"ACME server\") in a fully "
               "automated mode. The 'Options' are:"),
        example =>
            ["acme:",
             "  ca_url: https://acme-v02.api.letsencrypt.org/directory",
             "  contact:",
             "    - mailto:admin@domain.tld",
             "    - mailto:bot@domain.tld",
             "  auto: true",
             "  cert_type: rsa"]},
      [{ca_url,
        #{value => ?T("URL"),
          desc =>
              ?T("The ACME directory URL used as an entry point "
                 "for the ACME server. The default value is "
                 "<https://acme-v02.api.letsencrypt.org/directory> - "
                 "the directory URL of Let's Encrypt authority.")}},
       {contact,
        #{value => ?T("[Contact, ...]"),
          desc =>
              ?T("A list of contact addresses (typically emails) "
                 "where an ACME server will send notifications "
                 "when problems occur. The value of 'Contact' must "
                 "be in the form of \"scheme:address\" (e.g. "
                 "\"mailto:user@domain.tld\"). The default "
                 "is an empty list which means an ACME server "
                 "will send no notices.")}},
       {auto,
        #{value => "true | false",
          desc =>
              ?T("Whether to automatically request certificates for "
                 "all configured domains (that yet have no a certificate) "
                 "on server start or configuration reload. The default is 'true'.")}},
       {cert_type,
        #{value => "rsa | ec",
          desc =>
              ?T("A type of a certificate key. Available values are "
                 "'ec' and 'rsa' for EC and RSA certificates respectively. "
                 "It's better to have RSA certificates for the purpose "
                 "of backward compatibility with legacy clients and servers, "
                 "thus the default is 'rsa'.")}}]},
     {allow_contrib_modules,
      #{value => "true | false",
        desc =>
            ?T("Whether to allow installation of third-party modules or not. "
               "The default value is 'true'.")}},
     {allow_multiple_connections,
      #{value => "true | false",
        desc =>
            ?T("This option is only used when the anonymous mode is enabled. "
               "Setting it to 'true' means that the same username can be "
               "taken multiple times in anonymous login mode if different "
               "resource are used to connect. This option is only useful "
               "in very special occasions. The default value is 'false'.")}},
     {anonymous_protocol,
      #{value => "login_anon | sasl_anon | both",
        desc =>
            ?T("'login_anon' means that the anonymous login method will be used. "
               "'sasl_anon' means that the SASL Anonymous method will be used. "
               "'both' means that SASL Anonymous and login anonymous are both "
               "enabled. The default value is 'sasl_anon'.")}},
     {api_permissions,
      #{value => ?T("TODO"), desc => ?T("TODO")}},
     {append_host_config,
      #{value => "{Host: Options}",
        desc =>
            ?T("To define specific ejabberd modules in a virtual host, "
               "you can define the global 'modules' option with the common modules, "
               "and later add specific modules to certain virtual hosts. "
               "To accomplish that, 'append_host_config' option can be used.")}},
     {auth_cache_life_time,
      #{value => "timeout()",
        desc =>
            ?T("Same as 'cache_life_time', but applied to authentication cache "
               "only. If not set, the value from 'cache_life_time' will be used.")}},
     {auth_cache_missed,
      #{value => "true | false",
        desc =>
            ?T("Same as 'cache_missed', but applied to authentication cache "
               "only. If not set, the value from 'cache_missed' will be used.")}},
     {auth_cache_size,
      #{value => "pos_integer() | infinity",
        desc =>
            ?T("Same as 'cache_size', but applied to authentication cache "
               "only. If not set, the value from 'cache_size' will be used.")}},
     {auth_method,
      #{value => "[mnesia | sql | anonymous | external | jwt | ldap | pam, ...]",
        desc =>
            ?T("A list of authentication methods to use. "
               "If several methods are defined, authentication is "
               "considered successful as long as authentication of "
               "at least one of the methods succeeds. "
               "The default value is '[mnesia]'.")}},
     {auth_password_format,
      #{value => "plain | scram",
        desc =>
            ?T("The option defines in what format the users passwords "
               "are stored. 'plain': The password is stored as plain text "
               "in the database. This is risky because the passwords "
               "can be read if your database gets compromised. "
               "This is the default value. This format allows clients to "
               "authenticate using: the old Jabber Non-SASL (XEP-0078), "
               "SASL PLAIN, SASL DIGEST-MD5, and SASL SCRAM-SHA-1. "
               "'scram': The password is not stored, only some information "
               "that allows to verify the hash provided by the client. "
               "It is impossible to obtain the original plain password "
               "from the stored information; for this reason, when this "
               "value is configured it cannot be changed to plain anymore. "
               "This format allows clients to authenticate using: "
               "SASL PLAIN and SASL SCRAM-SHA-1.")}},
     {auth_use_cache,
      #{value => "true | false",
        desc =>
            ?T("Same as 'use_cache', but applied to authentication cache "
               "only. If not set, the value from 'use_cache' will be used.")}},
     {c2s_cafile,
      #{value => ?T("Path"),
        desc =>
            ?T("Full path to a file containing one or more CA certificates "
               "in PEM format. All client certificates should be signed by "
               "one of these root CA certificates and should contain the "
               "corresponding JID(s) in subjectAltName field. "
               "There is no default value.")}},
     {c2s_ciphers,
      #{value => "[Cipher, ...]",
        desc =>
            ?T("A list of OpenSSL ciphers. The default is "
               "'[\"HIGH\", \"!aNULL\", \"!eNULL\", \"!3DES\", \"@STRENGTH\"]'.")}},
     {c2s_dhfile,
      #{value => ?T("Path"),
        desc =>
            ?T("Full path to a file containing custom DH parameters. "
               "Such a file could be created with the command \"openssl "
               "dhparam -out dh.pem 2048\". If this option is not specified, "
               "2048-bit MODP Group with 256-bit Prime Order Subgroup will be "
               "used as defined in RFC5114 Section 2.3.")}},
     {c2s_protocol_options,
      #{value => "[Option, ...]",
        desc =>
            ?T("List of general options relating to SSL/TLS. "
               "These map to OpenSSL's 'set_options()'. The default value is: "
               "'[no_sslv3, cipher_server_preference, no_compression]'.")}},
     {c2s_tls_compression,
      #{value => "true | false",
        desc =>
            ?T("Whether to enable or disable TLS compression for c2s connections. "
               "The default value is 'false'.")}},
     {ca_file,
      #{value => ?T("Path"),
        desc =>
            ?T("Path to a file of CA root certificates. "
               "The default is to use system defined file if possible.")}},
     {captcha_cmd,
      #{value => ?T("Path"),
        desc =>
            ?T("Full path to a script that generates CAPTCHA images. "
               "There is no default value: when this option is not "
               "set, CAPTCHA functionality is completely disabled.")}},
     {captcha_limit,
      #{value => "pos_integer() | infinity",
        desc =>
            ?T("Maximum number of CAPTCHA generated images per minute for "
               "any given JID. The option is intended to protect the server "
               "from CAPTCHA DoS. The default value is 'infinity'.")}},
     {captcha_url,
      #{value => ?T("URL"),
        desc =>
            ?T("An URL where CAPTCHA requests should be sent. NOTE: you need "
               "to configure 'request_handlers' for 'ejabberd_http' listener "
               "as well. There is no default value.")}},
     {certfiles,
      #{value => "[Path, ...]",
        desc =>
            ?T("The option accepts a list of file paths (optionally with "
               "wildcards) containing either PEM certificates or PEM private "
               "keys. At startup, ejabberd sorts the certificates, "
               "finds matching private keys and rebuilds full certificates "
               "chains. Use this option when TLS is enabled in either of "
               "ejabberd listeners: 'ejabberd_c2s', 'ejabberd_http' and so on.")}},
     {cluster_backend,
      #{value => ?T("Backend"),
        desc =>
            ?T("A database backend to use for storing information about "
               "cluster. The only available value so far is 'mnesia'.")}},
     {cluster_nodes,
      #{value => "[Node, ...]",
        desc => ?T("TODO")}},
     {define_macro,
      #{value => "{MacroName: MacroValue}",
        desc =>
            ?T("Defines a macro. The value can be any valid arbitrary "
               "YAML value. For convenience, it's recommended to define "
               "a macro name in capital letters. Duplicated macros are not allowed. "
               "Macros are processed after additional configuration files have "
               "been included, so it is possible to use macros that are defined "
               "in configuration files included before the usage. "
               "It is possible to use a macro in the definition of another macro."),
        example =>
            ["define_macro:",
             "  DEBUG: debug",
             "  LOG_LEVEL: DEBUG",
             "  USERBOB:",
             "    user: bob@localhost",
             "",
             "loglevel: LOG_LEVEL",
             "",
             "acl:",
             "  admin: USERBOB"]}},
     {disable_sasl_mechanisms,
      #{value => "[Mechanism, ...]",
        desc =>
            ?T("Specify a list of SASL mechanisms (such as 'DIGEST-MD5' or "
               "'SCRAM-SHA1') that should not be offered to the client. "
               "For convenience, the value of 'Mechanism' is case-insensitive. "
               "The default value is an empty list, i.e. no mechanisms "
               "are disabled by default.")}},
     {domain_balancing,
      #{value => "{Domain: Options}",
        desc =>
            ?T("An algorithm to load balance the components that are plugged "
               "on an ejabberd cluster. It means that you can plug one or several "
               "instances of the same component on each ejabberd node and that "
               "the traffic will be automatically distributed. The algorithm "
               "to deliver messages to the component(s) can be specified by "
               "this option. For any component connected as 'Domain' available "
               "'Options' are:"),
        example =>
            ["domain_balancing:",
             "  x.domain.tld:",
             "    type: destination",
             "    component_number: 5",
             "  y.domain.tld:",
             "    type: bare_source"]},
      [{type,
        #{value => "random | source | destination | bare_source | bare_destination",
          desc =>
              ?T("How to deliver stanzas to connected components: "
                 "'random' - an instance is chosen at random; "
                 "'destination' - an instance is chosen by the full JID of "
                 "the packet's 'to' attribute; "
                 "'source' - by the full JID of the packet's 'from' attribute; "
                 "'bare_destination' - by the the bare JID (without resource) "
                 "of the packet's 'to' attribute; "
                 "'bare_source' - by the bare JID (without resource) of the "
                 "packet's 'from' attribute is used. The default value is 'random'.")}},
       {component_number,
        #{value => "2..1000",
          desc =>
              ?T("The number of components to balance.")}}]},
     {ext_api_headers,
      #{value => ?T("Headers"), desc => ?T("TODO")}},
     {ext_api_http_pool_size,
      #{value => ?T("Size"), desc => ?T("TODO")}},
     {ext_api_path_oauth,
      #{value => ?T("Path"), desc => ?T("TODO")}},
     {ext_api_url,
      #{value => ?T("URL"), desc => ?T("TODO")}},
     {extauth_pool_name,
      #{value => ?T("Pool"), desc => ?T("TODO")}},
     {extauth_pool_size,
      #{value => ?T("Size"),
        desc =>
            ?T("The option defines the number of instances of the same "
               "external program to start for better load balancing. "
               "The default is the number of available CPU cores.")}},
     {extauth_program,
      #{value => ?T("Path"),
        desc =>
            ?T("Indicate in this option the full path to the external "
               "authentication script. The script must be executable by ejabberd.")}},
     {fqdn,
      #{value => ?T("Domain"),
        desc =>
            ?T("A fully qualified domain name that will be used in "
               "SASL DIGEST-MD5 authentication. The default is detected "
               "automatically.")}},
     {hide_sensitive_log_data,
      #{value => "true | false",
        desc =>
            ?T("A privacy option to not log sensitive data "
               "(mostly IP addresses). The default value "
               "is 'false' for backward compatibility.")}},
     {host_config,
      #{value => "{Host: Options}",
        desc =>
            ?T("The option is used to redefine 'Options' for virtual host "
               "'Host'. In the example below LDAP authentication method "
               "will be used on virtual host 'domain.tld' and SQL method "
               "will be used on virtual host 'example.org'."),
        example =>
            ["hosts:",
             "  - domain.tld",
             "  - example.org",
             "",
             "auth_method:",
             "  - sql",
             "",
             "host_config:",
             "  domain.tld:",
             "    auth_method:",
             "      - ldap"]}},
     {include_config_file,
      #{value => "[Filename, ...\\] | {Filename: Options}",
        desc =>
            ?T("Read additional configuration from 'Filename'. If the "
               "value is provided in 'pass:[{Filename: Options}]' format, the "
               "'Options' must be one of the following:")},
      [{disallow,
        #{value => "[OptionName, ...]",
          desc =>
              ?T("Disallows the usage of those options in the included "
                 "file 'Filename'. The options that match this criteria "
                 "are not accepted. The default value is an empty list.")}},
       {allow_only,
        #{value => "[OptionName, ...]",
          desc =>
              ?T("Allows only the usage of those options in the included "
                 "file 'Filename'. The options that do not match this "
                 "criteria are not accepted. The default value is to include "
                 "all options.")}}]},
     {language,
      #{value => ?T("Language"),
        desc =>
            ?T("The option defines the default language of server strings "
               "that can be seen by XMPP clients. If an XMPP client does not "
               "possess 'xml:lang' attribute, the specified language is used.")}},
     {log_rotate_count,
      #{value => ?T("Number"),
        desc =>
            ?T("The number of rotated log files to keep. "
               "The default value is '1'.")}},
     {log_rotate_size,
      #{value => ?T("Size"),
        desc =>
            ?T("The size (in bytes) of a log file to trigger rotation. "
               "The default value is '10485760' (10 Mb).")}},
     {max_fsm_queue,
      #{value => ?T("Size"),
        desc =>
            ?T("This option specifies the maximum number of elements "
               "in the queue of the FSM (Finite State Machine). Roughly "
               "speaking, each message in such queues represents one "
               "XML stanza queued to be sent into its relevant outgoing "
               "stream. If queue size reaches the limit (because, for "
               "example, the receiver of stanzas is too slow), the FSM "
               "and the corresponding connection (if any) will be terminated "
               "and error message will be logged. The reasonable value for "
               "this option depends on your hardware configuration. "
               "The allowed values are positive integers. "
               "The default value is '10000'.")}},
     {negotiation_timeout,
      #{value => "timeout()",
        desc =>
            ?T("Time to wait for an XMPP stream negotiation to complete. "
               "When timeout occurs, the corresponding XMPP stream is closed. "
               "The default value is '30' seconds.")}},
     {net_ticktime,
      #{value => "timeout()",
        desc =>
            ?T("This option can be used to tune tick time parameter of "
               "'net_kernel'. It tells Erlang VM how often nodes should check "
               "if intra-node communication was not interrupted. This option "
               "must have identical value on all nodes, or it will lead to subtle "
               "bugs. Usually leaving default value of this is option is best, "
               "tweak it only if you know what you are doing. "
               "The default value is '1' minute.")}},
     {new_sql_schema,
      #{value => "true | false",
        desc =>
            {?T("Whether to use 'new' SQL schema. All schemas are located "
                "at <https://github.com/processone/ejabberd/tree/~s/sql>. "
                "There are two schemas available. The default lecacy schema "
                "allows to store one XMPP domain into one ejabberd database. "
                "The 'new' schema allows to handle several XMPP domains in a "
                "single ejabberd database. Using this 'new' schema is best when "
                "serving several XMPP domains and/or changing domains from "
                "time to time. This avoid need to manage several databases and "
                "handle complex configuration changes. The default depends on "
                "configuration flag '--enable-new-sql-schema' which is set "
                "at compile time."),
             [binary:part(ejabberd_config:version(), {0,5})]}}},
     {oauth_access,
      #{value => ?T("AccessName"),
        desc => ?T("By default creating OAuth tokens is not allowed. "
                   "To define which users can create OAuth tokens, "
                   "you can refer to an ejabberd access rule in the "
                   "'oauth_access' option. Use 'all' to allow everyone "
                   "to create tokens.")}},
     {oauth_cache_life_time,
      #{value => "timeout()",
        desc =>
            ?T("Same as 'cache_life_time', but applied to OAuth cache "
               "only. If not set, the value from 'cache_life_time' will be used.")}},
     {oauth_cache_missed,
      #{value => "true | false",
        desc =>
            ?T("Same as 'cache_missed', but applied to OAuth cache "
               "only. If not set, the value from 'cache_missed' will be used.")}},
     {oauth_cache_size,
      #{value => "pos_integer() | infinity",
        desc =>
            ?T("Same as 'cache_size', but applied to OAuth cache "
               "only. If not set, the value from 'cache_size' will be used.")}},
     {oauth_use_cache,
      #{value => "true | false",
        desc =>
            ?T("Same as 'use_cache', but applied to OAuth cache "
               "only. If not set, the value from 'use_cache' will be used.")}},
     {oauth_db_type,
      #{value => "mnesia | sql",
        desc =>
            ?T("Database backend to use for OAuth authentication. "
               "The default value is picked from 'default_db' option, or "
               "if it's not set, 'mnesia' will be used.")}},
     {oauth_expire,
      #{value => "timeout()",
        desc =>
            ?T("Time during which the OAuth token is valid, in seconds. "
               "After that amount of time, the token expires and the delegated "
               "credential cannot be used and is removed from the database. "
               "The default is '4294967' seconds.")}},
     {oauth_client_id_check,
      #{value => "allow | deny | db",
        desc => ?T("TODO")}},
     {oom_killer,
      #{value => "true | false",
        desc =>
            ?T("Enable or disable OOM (out-of-memory) killer. "
               "When system memory raises above the limit defined in "
               "'oom_watermark' option, ejabberd triggers OOM killer "
               "to terminate most memory consuming Erlang processes. "
               "Note that in order to maintain functionality, ejabberd only "
               "attempts to kill transient processes, such as those managing "
               "client sessions, s2s or database connections. "
               "The default value is 'true'.")}},
     {oom_queue,
      #{value => ?T("Size"),
        desc =>
            ?T("Trigger OOM killer when some of the running Erlang processes "
               "have messages queue above this 'Size'. Note that "
               "such processes won't be killed if 'oom_killer' option is set "
               "to 'false' or if 'oom_watermark' is not reached yet.")}},
     {oom_watermark,
      #{value => ?T("Percent"),
        desc =>
            ?T("A percent of total system memory consumed at which "
               "OOM killer should be activated with some of the processes "
               "possibly be killed (see 'oom_killer' option). Later, when "
               "memory drops below this 'Percent', OOM killer is deactivated. "
               "The default value is '80' percents.")}},
     {redis_connect_timeout,
      #{value => "timeout()",
        desc =>
            ?T("A timeout to wait for the connection to be re-established "
               "to the Redis server. The default is '1 second'.")}},
     {redis_db,
      #{value => ?T("Number"),
        desc => ?T("Redis database number. The default is '0'.")}},
     {redis_password,
      #{value => ?T("Password"),
        desc =>
            ?T("The password to the Redis server. "
               "The default is an empty string, i.e. no password.")}},
     {redis_pool_size,
      #{value => ?T("Number"),
        desc =>
            ?T("The number of simultaneous connections to the Redis server. "
               "The default value is '10'.")}},
     {redis_port,
      #{value => "1..65535",
        desc =>
            ?T("The port where the Redis server is accepting connections. "
               "The default is '6379'.")}},
     {redis_queue_type,
      #{value => "ram | file",
        desc =>
            ?T("The type of request queue for the Redis server. "
               "See description of 'queue_type' option for the explanation. "
               "The default value is the value defined in 'queue_type' "
               "or 'ram' if the latter is not set.")}},
     {redis_server,
      #{value => ?T("Hostname"),
        desc =>
            ?T("A hostname or an IP address of the Redis server. "
               "The default is 'localhost'.")}},
     {registration_timeout,
      #{value => "timeout()",
        desc =>
            ?T("This is a global option for module 'mod_register'. "
               "It limits the frequency of registrations from a given "
               "IP or username. So, a user that tries to register a "
               "new account from the same IP address or JID during "
               "this time after their previous registration "
               "will receive an error with the corresponding explanation. "
               "To disable this limitation, set the value to 'infinity'. "
               "The default value is '600 seconds'.")}},
     {resource_conflict,
      #{value => "setresource | closeold | closenew",
        desc =>
            ?T("NOTE: this option is deprecated and may be removed "
               "anytime in the future versions. The possible values "
               "match exactly the three possibilities described in "
               "https://tools.ietf.org/html/rfc6120#section-7.7.2.2"
               "[XMPP Core: section 7.7.2.2]. "
               "The default value is 'closeold'. If the client "
               "uses old Jabber Non-SASL authentication (XEP-0078), "
               "then this option is not respected, and the action performed "
               "is 'closeold'.")}}].

%%%===================================================================
%%% Internal functions
%%%===================================================================
